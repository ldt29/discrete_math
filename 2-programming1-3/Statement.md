# DM2022 1-3 图的遍历
## 问题描述
给定一个有向图 G，给出一个起始结点，给出对此图进行广探法（BFS）和深探法（DFS）搜索的结果。算法过程描述见课程文件：道路与回路（1）。

## 输入格式
从标准输入读取数据。

输入共 m + 1 行，表示一个 n 个结点 m 条边的 有向图。

第一行三个整数 n, m, s，表示图的 结点数、图的 边数、搜索的开始结点。

接下来 m + 1 行， 每行两个整数 u, v，表示一条始点为 u、终点为 v 的 有向边，输入的第 i 条边的编号为 i。

输入中每行相邻的整数之间由一个空格隔开。

在本题中，所有编号（如 “第 i 行” 的 i、 “结点 i” 的 i）从 1 开始。

## 输出格式
输出到标准输出。

输出两行。每行有若干个整数，相邻的整数之间由一个空格隔开。

第一行是对此图使用广探法（BFS）进行搜索时访问的结点编号序列。

第二行是对此图使用深探法（DFS）进行搜索时访问的结点编号序列。

我们规定，当一个结点具有多条出边时，我们按照边的编号 从大到小 进行访问。此外，每当访问到某一个结点时，先输出该结点的编号，再从该结点开始搜索后继结点。

## 样例输入
```
5 5 1
1 3
1 2
2 4
4 5
3 5
```
## 样例输出
```
1 2 3 4 5
1 2 4 5 3
```
## 样例解释
该样例输入对应的有向图如下：

![image](https://user-images.githubusercontent.com/72798752/174547519-c22c9095-fcea-432d-bccb-6c0fa32f0fb5.png)


BFS 进行访问的流程如下：

从结点 1 出发，寻找结点 1 的出边，发现有 1-2, 1-3 两条；结点 2 和结点 3 都还未访问过；对结点 1 的搜索结束；

访问结点 2，发现有出边 2-4，结点 4 还未搜索过；对结点 2 的搜索结束；

访问结点 3，发现有出边 3-5，结点 5 还未搜索过；对结点 3 的搜索结束；

访问结点 4，发现有出边 4-5，结点 5 还未搜索过；结点 4 搜索完成；

访问结点 5，发现没有出边；对结点 5 搜索完成；

算法结束；对结点的访问顺序为
```
1 2 3 4 5
```
DFS 进行访问的流程如下：

从结点 1 出发，寻找结点 1 的出边，发现有 1-2, 1-3 两条；结点 2 和结点 3 都还未访问过；

访问结点 2，发现有出边 2-4，结点 4 还未被访问过；

访问结点 4，发现有出边 4-5，结点 5 还未被访问过；

访问结点 5，发现没有出边；

对结点 5 搜索完成，返回结点 4；

结点 4 没有其他出边，对结点 4 搜索完成，返回结点 2；

结点 2 没有其他出边，对结点 2 搜索完成，返回结点 1；

在结点 1，发现出边指向的结点中，结点 3 还未被访问过；

访问结点 3，发现有出边 3-5，结点 5 已经被访问过；对结点 3 搜索完成，返回结点 1；

结点 1 搜索完成，算法结束。

对结点的访问顺序为
```
1 2 4 5 3
```
## 数据范围与约定
1 ≤ n ≤ 200000, 1 ≤ m ≤ 1000000

1 ≤ s ≤ n

1 ≤ u, v ≤ n

注意：图 G 中可能存在重边和自环

时间限制：1 秒

内存限制：256 MiB

## 提示
思考与提示：

1. 如果你已经学过队列和栈，如何利用这两种数据结构编写 BFS 或 DFS 算法？
2. 你也可以 不借助队列和栈 解决本题，请你思考可行的做法。
3. 如果你希望学习队列和栈，可以参考如下资料：
    * 资料 A （算法介绍）
        * https://en.wikipedia.org/wiki/Queue_(abstract_data_type)
        * https://en.wikipedia.org/wiki/Stack_(abstract_data_type)
        * https://en.wikipedia.org/wiki/Stack_(C%2B%2B)
    * 资料 B （STL 文档）
        * https://en.cppreference.com/w/cpp/container/stack
        * https://en.cppreference.com/w/cpp/container/queue
    * 资料 C （数据结构课程）
        * 学堂在线平台邓俊辉老师《数据结构(上)》课程，第四章：栈和队列。
